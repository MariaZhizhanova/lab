# Тема 9. Концепции и принципы ООП 
Отчет по Теме #9 выполнил(а):
- Жижанова Мария Вячеславовна
- ЗПИЭ 20-1

| Задание | Сам_раб |
| ------ |  ------ |
| Задание 1 | + | - |
| Задание 2 | - | - |
| Задание 3 | - | - |
| Задание 4 | - | - |
| Задание 5 | - | - |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.


## Самостоятельная работа №1
### 1)1)	Создайте класс Tomato
2)	Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3)	Создайте метод	init	(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state
 
(принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4)	Создайте метод grow(), который будет переводить томат на следующую стадию созревания
5)	Создайте метод is_ripe(), который будет проверять, что томат созрел 


```python
class Tomato:
    # 2) Создаем статическое свойство states с возможными стадиями созревания помидора
    states = {
        0: "Зеленый",
        1: "Начинает краснеть",
        2: "Красный и спелый"
    }

    # 3) Создаем метод init для инициализации объекта
    def __init__(self, _index):
        self._index = _index  # _index - это динамическое свойство, переданное параметром
        self._state = self.states[0]  # _state - динамическое свойство, инициализируется начальным состоянием "Зеленый"

    # 4) Создаем метод grow для перевода томата на следующую стадию созревания
    def grow(self):
        if self._state != self.states[2]:
            current_state_index = list(self.states.values()).index(self._state)
            self._state = self.states[current_state_index + 1]

    # 5) Создаем метод is_ripe для проверки, что томат созрел
    def is_ripe(self):
        return self._state == self.states[2]

# Создаем объект класса Tomato
tomato = Tomato(0)

# Пример использования методов
print("Текущее состояние:", tomato._state)  # Выводит: Текущее состояние: Зеленый
tomato.grow()  # Переводим томат на следующую стадию созревания
print("Текущее состояние:", tomato._state)  # Выводит: Текущее состояние: Начинает краснеть

# Проверяем, созрел ли томат
if tomato.is_ripe():
    print("Томат созрел!")
else:
    print("Томат еще не созрел.")

```
- Скрины консоли
  ![image](https://github.com/MariaZhizhanova/lab/assets/145640698/861f2746-5bfa-4e20-875f-8a6bc2a0edfb)

- Развернутый вывод
- Мы создали класс Tomato.
В классе Tomato создали статическое свойство states, которое содержит все стадии созревания помидора.
В методе __init__ инициализировали два динамических свойства: _index (передается параметром) и _state (устанавливается начальным значением из словаря states).
Создали метод grow, который переводит томат на следующую стадию созревания (если он не достиг последней стадии).
Создали метод is_ripe, который проверяет, что томат созрел (находится на последней стадии созревания).
  
## Самостоятельная работа №2
### 2)	Класс TomatoBush:
1)	Создайте класс TomatoBush
2)	Определите метод	init	(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes
3)	Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4)	Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.
5)	Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая



```python
class Tomato:
    def __init__(self):
        self.ripe = False

class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato() for _ in range(num_tomatoes)]

    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.ripe = True

    def all_are_ripe(self):
        return all(tomato.ripe for tomato in self.tomatoes)

    def give_away_all(self):
        self.tomatoes = []

# Пример использования класса TomatoBush:
bush = TomatoBush(5)  # Создаем куст томатов с 5 томатами
bush.grow_all()       # Переводим все томаты на следующий этап созревания
print(bush.all_are_ripe())  # Проверяем, все ли томаты спелые (должно быть False)
bush.give_away_all()       # Собираем урожай и очищаем список томатов
print(bush.all_are_ripe())  # Проверяем снова, все ли томаты спелые (должно быть False, так как список пуст)
```

![image](https://github.com/MariaZhizhanova/lab/assets/145640698/a00fb223-103d-4fa7-b080-dcb4186ca2e5)

class Tomato: - Здесь определяется класс Tomato, представляющий томат.
def __init__(self): - Это конструктор класса Tomato, вызывается при создании нового объекта. self ссылается на созданный объект.
self.ripe = False - Создается атрибут ripe объекта Tomato, который указывает на степень созревания томата и изначально устанавливается в False.
Теперь посмотрим на код для класса TomatoBush:

class TomatoBush: - Определяется класс TomatoBush, представляющий куст томатов.

def __init__(self, num_tomatoes): - Конструктор класса TomatoBush, который принимает количество томатов и создает список томатов заданного количества.

self.tomatoes = [Tomato() for _ in range(num_tomatoes)] - Здесь создается список томатов, используя генератор списка. Для каждого элемента создается новый объект Tomato.
def grow_all(self): - Метод grow_all, который переводит все томаты в кусте на следующий этап созревания.

for tomato in self.tomatoes: - Цикл, который проходит по всем объектам томатов в списке.
tomato.ripe = True - Устанавливает атрибут ripe каждого томата в True.
def all_are_ripe(self): - Метод all_are_ripe, который возвращает True, если все томаты из списка стали спелыми.

return all(tomato.ripe for tomato in self.tomatoes) - Использует функцию all(), чтобы проверить, все ли томаты имеют ripe = True.
def give_away_all(self): - Метод give_away_all, который чистит список томатов после сбора урожая.

self.tomatoes = [] - Устанавливает атрибут tomatoes в пустой список, очищая куст от томатов.
После определения классов, создается экземпляр класса TomatoBush и выполняются некоторые действия, чтобы продемонстрировать функциональность этих классов.

  
## Самостоятельная работа №3

### 3)	Класс Gardener:
1)	Создайте класс Gardener
2)	Создайте метод	init	(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3)	Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4)	Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5)	Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству


```python
class TomatoBush:
    def __init__(self):
        self.ripe_fruits = 0

    def grow_all(self):
        self.ripe_fruits += 1

    def all_are_ripe(self):
        return self.ripe_fruits >= 5

    def give_away_all(self):
        self.ripe_fruits = 0
        print("Все плоды собраны и отданы.")

class Gardener:
    def __init__(self, name, plant):
        self.name = name  
        self._plant = plant 

    def work(self):
        """Метод, который заставляет садовника работать, что позволяет растению становиться более зрелым."""
        self._plant.grow_all()

    def harvest(self):
        """Метод, который проверяет, все ли плоды созрели и собирает урожай."""
        if self._plant.all_are_ripe():
            print(f"{self.name} собрал урожай.")
            self._plant.give_away_all()
        else:
            print("Не все плоды созрели. Подождите немного.")

    @staticmethod
    def knowledge_base():
        """Статический метод для вывода справки по садоводству."""
        print("Справка по садоводству:")
        print("1. Поливайте растения регулярно.")
        print("2. Удобряйте по необходимости.")
        print("3. Следите за созреванием плодов.")

if __name__ == "__main__":
    tomato_bush = TomatoBush()
    gardener = Gardener("Иван", tomato_bush)

    gardener.work()
    gardener.work()
    gardener.work()
    gardener.work()
    gardener.work()
    gardener.harvest()
```


- ![image](https://github.com/MariaZhizhanova/lab/assets/145640698/98a04286-e43d-46cf-b21c-20344124168c)
class TomatoBush: - Здесь определен класс TomatoBush, представляющий томатный куст.

def __init__(self): - Это конструктор класса TomatoBush, который инициализирует экземпляр куста. У куста есть атрибут ripe_fruits, который изначально равен 0.

def grow_all(self): - Метод grow_all увеличивает количество созревших плодов на кусте на 1.

def all_are_ripe(self): - Метод all_are_ripe проверяет, все ли плоды созрели (их количество больше или равно 5) и возвращает булево значение.

def give_away_all(self): - Метод give_away_all собирает все созревшие плоды, устанавливая ripe_fruits в 0, и выводит сообщение о сборе урожая.

class Gardener: - Здесь определен класс Gardener, представляющий садовника.

def __init__(self, name, plant): - Конструктор класса Gardener принимает имя садовника и растение, которым он будет заботиться. Растение сохраняется в атрибуте _plant.

def work(self): - Метод work "заставляет" садовника работать, вызывая метод grow_all у растения, что увеличивает количество созревших плодов.

def harvest(self): - Метод harvest проверяет, все ли плоды созрели с помощью метода all_are_ripe растения. Если да, то садовник собирает урожай (вызывает give_away_all), иначе выводит сообщение о том, что не все плоды созрели.

@staticmethod - Это декоратор, который определяет следующий метод как статический, то есть метод, который не требует доступа к атрибутам экземпляра класса.

def knowledge_base(): - Это статический метод knowledge_base, который выводит справку по садоводству.

if __name__ == "__main__": - Эта строка проверяет, запущен ли этот скрипт напрямую (а не импортирован ли он как модуль в другой скрипт).

tomato_bush = TomatoBush() - Создается экземпляр класса TomatoBush.

gardener = Gardener("Иван", tomato_bush) - Создается экземпляр класса Gardener с именем "Иван" и растением tomato_bush.

gardener.work() - Садовник "работает", вызывая метод work пять раз, увеличивая количество созревших плодов.

gardener.harvest() - Садовник проверяет, можно ли собирать урожай, и в данном случае собирает его, так как пять плодов уже созрели, и затем обнуляет счетчик плодов.
- 
  



## Самостоятельная работа №5
### 5)	Тесты:
1)	Вызовите справку по садоводству
2)	Создайте объекты классов TomatoBush и Gardener
3)	Используя объект класса Gardener, поухаживайте за кустом с помидорами
4)	Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
 
5)	Соберите урожай
Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполенния всех тестов.



```python

```

  

## Общие выводы по теме
- Развернутый вывод




