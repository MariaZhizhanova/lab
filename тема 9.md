# Тема 9. Концепции и принципы ООП 
Отчет по Теме #9 выполнил(а):
- Жижанова Мария Вячеславовна
- ЗПИЭ 20-1

| Задание | Сам_раб |
| ------ |  ------ |
| Задание 1 | + | - |
| Задание 2 | - | - |
| Задание 3 | - | - |
| Задание 4 | - | - |
| Задание 5 | - | - |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.


## Самостоятельная работа №1
### 1)1)	Создайте класс Tomato
2)	Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3)	Создайте метод	init	(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state
 
(принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4)	Создайте метод grow(), который будет переводить томат на следующую стадию созревания
5)	Создайте метод is_ripe(), который будет проверять, что томат созрел 


```python
class Tomato:
    # 2) Создаем статическое свойство states с возможными стадиями созревания помидора
    states = {
        0: "Зеленый",
        1: "Начинает краснеть",
        2: "Красный и спелый"
    }

    # 3) Создаем метод init для инициализации объекта
    def __init__(self, _index):
        self._index = _index  # _index - это динамическое свойство, переданное параметром
        self._state = self.states[0]  # _state - динамическое свойство, инициализируется начальным состоянием "Зеленый"

    # 4) Создаем метод grow для перевода томата на следующую стадию созревания
    def grow(self):
        if self._state != self.states[2]:
            current_state_index = list(self.states.values()).index(self._state)
            self._state = self.states[current_state_index + 1]

    # 5) Создаем метод is_ripe для проверки, что томат созрел
    def is_ripe(self):
        return self._state == self.states[2]

# Создаем объект класса Tomato
tomato = Tomato(0)

# Пример использования методов
print("Текущее состояние:", tomato._state)  # Выводит: Текущее состояние: Зеленый
tomato.grow()  # Переводим томат на следующую стадию созревания
print("Текущее состояние:", tomato._state)  # Выводит: Текущее состояние: Начинает краснеть

# Проверяем, созрел ли томат
if tomato.is_ripe():
    print("Томат созрел!")
else:
    print("Томат еще не созрел.")

```
- Скрины консоли
  ![image](https://github.com/MariaZhizhanova/lab/assets/145640698/861f2746-5bfa-4e20-875f-8a6bc2a0edfb)

- Развернутый вывод
- Мы создали класс Tomato.
В классе Tomato создали статическое свойство states, которое содержит все стадии созревания помидора.
В методе __init__ инициализировали два динамических свойства: _index (передается параметром) и _state (устанавливается начальным значением из словаря states).
Создали метод grow, который переводит томат на следующую стадию созревания (если он не достиг последней стадии).
Создали метод is_ripe, который проверяет, что томат созрел (находится на последней стадии созревания).
  
## Самостоятельная работа №2
### 2)	Класс TomatoBush:
1)	Создайте класс TomatoBush
2)	Определите метод	init	(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes
3)	Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4)	Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.
5)	Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая



```python
class Tomato:
    def __init__(self):
        self.ripe = False

class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato() for _ in range(num_tomatoes)]

    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.ripe = True

    def all_are_ripe(self):
        return all(tomato.ripe for tomato in self.tomatoes)

    def give_away_all(self):
        self.tomatoes = []

# Пример использования класса TomatoBush:
bush = TomatoBush(5)  # Создаем куст томатов с 5 томатами
bush.grow_all()       # Переводим все томаты на следующий этап созревания
print(bush.all_are_ripe())  # Проверяем, все ли томаты спелые (должно быть False)
bush.give_away_all()       # Собираем урожай и очищаем список томатов
print(bush.all_are_ripe())  # Проверяем снова, все ли томаты спелые (должно быть False, так как список пуст)
```

![image](https://github.com/MariaZhizhanova/lab/assets/145640698/a00fb223-103d-4fa7-b080-dcb4186ca2e5)

class Tomato: - Здесь определяется класс Tomato, представляющий томат.
def __init__(self): - Это конструктор класса Tomato, вызывается при создании нового объекта. self ссылается на созданный объект.
self.ripe = False - Создается атрибут ripe объекта Tomato, который указывает на степень созревания томата и изначально устанавливается в False.
Теперь посмотрим на код для класса TomatoBush:

class TomatoBush: - Определяется класс TomatoBush, представляющий куст томатов.

def __init__(self, num_tomatoes): - Конструктор класса TomatoBush, который принимает количество томатов и создает список томатов заданного количества.

self.tomatoes = [Tomato() for _ in range(num_tomatoes)] - Здесь создается список томатов, используя генератор списка. Для каждого элемента создается новый объект Tomato.
def grow_all(self): - Метод grow_all, который переводит все томаты в кусте на следующий этап созревания.

for tomato in self.tomatoes: - Цикл, который проходит по всем объектам томатов в списке.
tomato.ripe = True - Устанавливает атрибут ripe каждого томата в True.
def all_are_ripe(self): - Метод all_are_ripe, который возвращает True, если все томаты из списка стали спелыми.

return all(tomato.ripe for tomato in self.tomatoes) - Использует функцию all(), чтобы проверить, все ли томаты имеют ripe = True.
def give_away_all(self): - Метод give_away_all, который чистит список томатов после сбора урожая.

self.tomatoes = [] - Устанавливает атрибут tomatoes в пустой список, очищая куст от томатов.
После определения классов, создается экземпляр класса TomatoBush и выполняются некоторые действия, чтобы продемонстрировать функциональность этих классов.

  
## Самостоятельная работа №3

### 3)	Класс Gardener:
1)	Создайте класс Gardener
2)	Создайте метод	init	(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3)	Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4)	Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5)	Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству


```python

```


- 
- 
  
## Самостоятельная работа №4

### 4)	Напишите программу, которая получает на вход предложение, выводит его в терминал, заменяя все запрещенные слова звездочками * (количество звездочек равно количеству букв в слове). Запрещенные слова, разделенные символом пробела, хранятся в текстовом файле input.txt. Все слова в этом файле записаны в нижнем регистре. Программа должна заменить запрещенные слова, где бы они ни встречались, даже в середине другого слова. Замена производится независимо от регистра: если файл input.txt содержит запрещенное слово exam, то слова exam, Exam, ExaM, EXAM и exAm должны быть заменены на ****.
### •	Запрещенные слова:
### hello email python the exam wor is
### •	Предложение для проверки:
### Hello, world! Python IS the programming language of thE future. My EMAIL is....
### PYTHON is awesome!!!!
### •	Ожидаемый результат:
### *****, ***ld! ****** ** *** programming language of *** future. My
### ***** **....
### ****** ** awesome!!!!


	


```python



```
- 


## Самостоятельная работа №5
### 5)	Самостоятельно придумайте и решите задачу, которая будет взаимодействовать с текстовым файлом.


```python

```

  

## Общие выводы по теме
- Развернутый вывод




