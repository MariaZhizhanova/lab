# ТЕМА 11. Итераторы и генераторы
Отчет по Теме # 11 выполнил(а):
- Жижанова Мария Вячеславовна
- ЗПИЭ 20-1

| Задание | Сам_раб |
| ------ |  ------ |
| Задание 1 | + | - |
| Задание 2 | + | - |



знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Вас никак не могут оставить числа Фибоначчи, очень уж они вас заинтересовали. Изучив новые возможности Python вы решили реализовать программу, которая считает числа Фибоначчи при помощи итераторов. Расчет начинается с чисел 1 и 1. Создайте функцию fib(n), генерирующую n чисел Фибоначчи с минимальными затратами ресурсов. Для реализации этой функции потребуется обратиться к инструкции yield (Она не сохраняет в оперативной памяти огромную последовательность, а дает возможность “доставать” промежуточные результаты по одному). 
Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200.
## Самостоятельная работа №1
### 1)
1)	Вас никак не могут оставить числа Фибоначчи, очень уж они вас заинтересовали. Изучив новые возможности Python вы решили реализовать программу, которая считает числа Фибоначчи при помощи итераторов.
3)
   Расчет начинается с чисел 1 и 1. Создайте функцию fib(n), генерирующую n чисел Фибоначчи с минимальными затратами ресурсов. Для реализации этой функции потребуется обратиться к инструкции yield (Она не сохраняет в оперативной памяти огромную последовательность, а дает возможность “доставать” промежуточные результаты по одному).
5)	Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200.
```python
class Сотрудник:
    def __init__(self, имя, фамилия, должность, зарплата):
        self.имя = имя
        self.фамилия = фамилия
        self.должность = должность
        self.зарплата = зарплата

    def информация(self):
        return f"{self.имя} {self.фамилия}, {self.должность}, Зарплата: {self.зарплата} рублей в месяц"
        
сотрудник1 = Сотрудник("Иван", "Иванов", "Менеджер", 50000)
сотрудник2 = Сотрудник("Петр", "Петров", "Разработчик", 70000)

print(сотрудник1.информация())
print(сотрудник2.информация())
```
- ![image](https://github.com/MariaZhizhanova/lab/assets/145640698/cc5caa29-aecb-49be-8da8-dbe6264dc00f)

## Вывод
В данном коде определен  класс Сотрудник, который имеет конструктор __init__ для инициализации атрибутов (имя, фамилия, должность и зарплата) и метод информация(), который возвращает строку с информацией о сотруднике. На выводе мы получаем информацию о каждом из них, включая их имя, фамилию, должность и зарплату.
  
## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Сотрудник:
    def __init__(self, имя, фамилия, должность, зарплата):
        self.имя = имя
        self.фамилия = фамилия
        self.должность = должность
        self.зарплата = зарплата
        self.проекты = []

    def информация(self):
        return f"{self.имя} {self.фамилия}, {self.должность}, Зарплата: {self.зарплата} рублей в месяц"

    def добавить_проект(self, проект):
        self.проекты.append(проект)
        return f"Проект '{проект}' добавлен для {self.имя} {self.фамилия}"

сотрудник1 = Сотрудник("Иван", "Иванов", "Менеджер", 50000)
сотрудник2 = Сотрудник("Петр", "Петров", "Разработчик", 70000)

print(сотрудник1.добавить_проект("Проект 1"))
print(сотрудник2.добавить_проект("Проект 2"))

print(сотрудник1.информация())
print(сотрудник2.информация())
```

![image](https://github.com/MariaZhizhanova/lab/assets/145640698/3bd5fc99-2ad3-42d2-8610-079b7298cf23)

## Вывод
В данной задаче реализован, код который создает сотрудников, добавляет им проекты и выводит информацию о каждом сотруднике с их данными, должностями и зарплатами.

## Самостоятельная работа №3

### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Сотрудник:
    def __init__(self, имя, фамилия, должность, зарплата):
        self.имя = имя
        self.фамилия = фамилия
        self.должность = должность
        self.зарплата = зарплата
        self.проекты = []

    def информация(self):
        return f"{self.имя} {self.фамилия}, {self.должность}, Зарплата: {self.зарплата} рублей в месяц"

    def добавить_проект(self, проект):
        self.проекты.append(проект)
        return f"Проект '{проект}' добавлен для {self.имя} {self.фамилия}"

class Руководитель(Сотрудник):
    def __init__(self, имя, фамилия, должность, зарплата, подчиненные=None):
        super().__init__(имя, фамилия, должность, зарплата)
        self.подчиненные = подчиненные or []

    def добавить_подчиненного(self, подчиненный):
        self.подчиненные.append(подчиненный)
        return f"{подчиненный.имя} {подчиненный.фамилия} добавлен(а) в список подчиненных для {self.имя} {self.фамилия}"

сотрудник1 = Сотрудник("Иван", "Иванов", "Менеджер", 50000)
сотрудник2 = Сотрудник("Петр", "Петров", "Разработчик", 70000)

руководитель1 = Руководитель("Анна", "Иванова", "Руководитель отдела", 80000)
сотрудник3 = Сотрудник("Мария", "Сидорова", "Ассистент", 40000)

print(сотрудник1.добавить_проект("Проект 1"))
print(сотрудник2.добавить_проект("Проект 2"))

print(сотрудник1.информация())
print(сотрудник2.информация())

print(руководитель1.добавить_проект("Проект 3"))
print(руководитель1.добавить_подчиненного(сотрудник3))

print(руководитель1.информация())
```
![image](https://github.com/MariaZhizhanova/lab/assets/145640698/f21effdc-10ba-4060-bb68-81e8cd857fc5)

## Вывод
В данной задаче мы используем классы и наследование для определения структуры организации сотрудников и их проектов.

## Самостоятельная работа №4

### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Сотрудник:
    def __init__(self, имя, фамилия, должность, зарплата):
        self.__имя = имя
        self.__фамилия = фамилия
        self.__должность = должность
        self.__зарплата = зарплата
        self.__проекты = []

    def информация(self):
        return f"{self.__имя} {self.__фамилия}, {self.__должность}, Зарплата: {self.__зарплата} рублей в месяц"

    def добавить_проект(self, проект):
        self.__проекты.append(проект)
        return f"Проект '{проект}' добавлен для {self.__имя} {self.__фамилия}"

class Руководитель(Сотрудник):
    def __init__(self, имя, фамилия, должность, зарплата, подчиненные=None):
        super().__init__(имя, фамилия, должность, зарплата)
        self.__подчиненные = подчиненные or []

    def добавить_подчиненного(self, подчиненный):
        self.__подчиненные.append(подчиненный)
        return f"{подчиненный.имя} {подчиненный.фамилия} добавлен(а) в список подчиненных для {self.__имя} {self.__фамилия}"

сотрудник1 = Сотрудник("Иван", "Иванов", "Менеджер", 50000)
сотрудник2 = Сотрудник("Петр", "Петров", "Разработчик", 70000)

руководитель1 = Руководитель("Анна", "Иванова", "Руководитель отдела", 80000)
сотрудник3 = Сотрудник("Мария", "Сидорова", "Ассистент", 40000)

print(сотрудник1.добавить_проект("Проект 1"))
print(сотрудник2.добавить_проект("Проект 2"))

print(сотрудник1.информация())
print(сотрудник2.информация())

print(руководитель1.добавить_проект("Проект 3"))
print(руководитель1.добавить_подчиненного(сотрудник3))
```

- ![image](https://github.com/MariaZhizhanova/lab/assets/145640698/61cea4c5-4142-4c76-8fa8-a1f981a443e7)

## Вывод
В данной задаче  определены два класса: Сотрудник и Руководитель, и созданы объекты этих классов.В конце программа выводит информацию о сотрудниках и руководителе, а также сообщения о добавлении проектов и подчиненных. Использование двойных подчеркиваний делает атрибуты имя, фамилия, должность, зарплата и проекты недоступными для прямого доступа извне класса. Это обеспечивает инкапсуляцию данных и защищает их от непреднамеренных изменений извне класса.

## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Сотрудник:
    def __init__(self, имя, фамилия, должность, зарплата):
        self.__имя = имя
        self.__фамилия = фамилия
        self.__должность = должность
        self.__зарплата = зарплата
        self.__проекты = []

    def информация(self):
        return f"{self.__имя} {self.__фамилия}, {self.__должность}, Зарплата: {self.__зарплата} рублей в месяц"

    def добавить_проект(self, проект):
        self.__проекты.append(проект)
        return f"Проект '{проект}' добавлен для {self.__имя} {self.__фамилия}"

    def расчет_зарплаты(self):
        return self.__зарплата

class Руководитель(Сотрудник):
    def __init__(self, имя, фамилия, должность, зарплата, подчиненные=None, бонус=0):
        super().__init__(имя, фамилия, должность, зарплата)
        self.__подчиненные = подчиненные or []
        self.__бонус = бонус

    def добавить_подчиненного(self, подчиненный):
        self.__подчиненные.append(подчиненный)
        return f"{подчиненный._Сотрудник__имя} {подчиненный._Сотрудник__фамилия} добавлен(а) в список подчиненных для {self._Сотрудник__имя} {self._Сотрудник__фамилия}"

    def расчет_зарплаты(self):
        базовая_зарплата = super().расчет_зарплаты()
        итоговая_зарплата = базовая_зарплата + self.__бонус
        return итоговая_зарплата

сотрудник1 = Сотрудник("Иван", "Иванов", "Менеджер", 50000)
сотрудник2 = Сотрудник("Петр", "Петров", "Разработчик", 70000)

руководитель1 = Руководитель("Анна", "Иванова", "Руководитель отдела", 80000, бонус=10000)
сотрудник3 = Сотрудник("Мария", "Сидорова", "Ассистент", 40000)

print(сотрудник1.добавить_проект("Проект 1"))
print(сотрудник2.добавить_проект("Проект 2"))

print(сотрудник1.информация())
print(сотрудник2.информация())

print(руководитель1.добавить_проект("Проект 3"))
print(руководитель1.добавить_подчиненного(сотрудник3))

print(сотрудник1.расчет_зарплаты())
print(руководитель1.расчет_зарплаты())
```

![image](https://github.com/MariaZhizhanova/lab/assets/145640698/29e1a8bd-5716-4041-b7ba-d412e8abef97)

## Вывод
В данной задача мы моделируем иерархию сотрудников и руководителей в организации, в представленном коде полиморфизм реализуется через переопределение метода расчет_зарплаты в классе Руководитель, который расширяет или изменяет поведение метода из родительского класса Сотрудник.

## Общие выводы по теме
- Развернутый вывод


